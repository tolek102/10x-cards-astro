name: Pull Request Checks Master

on:
  pull_request:
    branches: [ master ]
    types: [opened, synchronize, reopened] # Uruchamiaj przy otwarciu, aktualizacji lub ponownym otwarciu PR

permissions: # Ustawienie domy≈õlnych uprawnie≈Ñ dla ca≈Çego workflow
  contents: read    # Potrzebne do checkoutu kodu i odczytu .nvmrc

jobs:
  lint_and_test:
    name: Lint and Test
    runs-on: ubuntu-latest

    outputs: # Definiujemy wyj≈õcia tego joba, kt√≥re przeka≈ºemy do joba komentujƒÖcego
      lint_outcome: ${{ steps.lint.outcome }}
      test_outcome: ${{ steps.test.outcome }}
      lint_results_path: ./lint-results.json # ≈öcie≈ºka do pliku z wynikami lintera
      test_results_path: ./test-results.json # ≈öcie≈ºka do pliku z wynikami test√≥w

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js from .nvmrc
        uses: actions/setup-node@v4
        with:
          node-version-file: '.nvmrc' # U≈ºywa wersji Node.js z pliku .nvmrc
          cache: 'npm' # W≈ÇƒÖcza cache'owanie zale≈ºno≈õci npm dla szybszych build√≥w

      - name: Install dependencies
        run: npm ci # U≈ºywaj 'ci' zamiast 'install' w CI dla deterministycznych instalacji

      - name: Run Linter
        id: lint # Nadajemy ID krokowi, aby m√≥c odwo≈Çaƒá siƒô do jego wyniku (outcome)
        # Uruchamiamy lintera z formatem JSON dla ≈Çatwiejszego parsowania i zapisujemy do pliku
        # U≈ºywamy `|| true`, aby krok nie zako≈Ñczy≈Ç siƒô b≈Çƒôdem, je≈õli lint znajdzie problemy. Sprawdzimy wynik w kolejnym jobie.
        run: npm run lint -- --format json --output-file lint-results.json || true
        continue-on-error: true # Pozwalamy workflow kontynuowaƒá nawet je≈õli ten krok "zako≈Ñczy siƒô niepowodzeniem" (ze wzglƒôdu na `|| true` to nie nastƒÖpi, ale outcome bƒôdzie 'failure')

      - name: Run Unit Tests
        id: test # Nadajemy ID krokowi
        # Uruchamiamy testy z reporterem JSON i zapisujemy do pliku
        # U≈ºywamy `npx vitest run`, aby upewniƒá siƒô, ≈ºe uruchamiamy testy jednorazowo (nie w trybie watch)
        # U≈ºywamy `|| true`, aby krok nie zako≈Ñczy≈Ç siƒô b≈Çƒôdem, je≈õli testy nie przejdƒÖ. Sprawdzimy wynik w kolejnym jobie.
        run: npx vitest run --reporter=json --outputFile=test-results.json || true
        continue-on-error: true # Pozwalamy workflow kontynuowaƒá

      - name: Upload Lint Results Artifact
        uses: actions/upload-artifact@v4
        if: always() # Zawsze uploaduj artefakt, niezale≈ºnie od wyniku kroku lint
        with:
          name: lint-results # Nazwa artefaktu
          path: ${{ steps.lint_and_test.outputs.lint_results_path }} # ≈öcie≈ºka zdefiniowana w outputs joba
          retention-days: 1 # Jak d≈Çugo przechowywaƒá artefakt

      - name: Upload Test Results Artifact
        uses: actions/upload-artifact@v4
        if: always() # Zawsze uploaduj artefakt
        with:
          name: test-results # Nazwa artefaktu
          path: ${{ steps.lint_and_test.outputs.test_results_path }} # ≈öcie≈ºka zdefiniowana w outputs joba
          retention-days: 1

  status_comment:
    name: Post Status Comment
    runs-on: ubuntu-latest
    needs: lint_and_test # Ten job uruchomi siƒô dopiero po zako≈Ñczeniu joba lint_and_test
    if: always() # Uruchom ten job zawsze, nawet je≈õli lint_and_test siƒô nie powi√≥d≈Ç (aby m√≥c skomentowaƒá o b≈Çƒôdzie)
    permissions:
      pull-requests: write # Potrzebne do dodawania komentarzy do PR

    steps:
      - name: Download Lint Results Artifact
        uses: actions/download-artifact@v4
        with:
          name: lint-results # Nazwa artefaktu zdefiniowana w jobie lint_and_test
          path: ./ # Pobierz do bie≈ºƒÖcego katalogu

      - name: Download Test Results Artifact
        uses: actions/download-artifact@v4
        with:
          name: test-results # Nazwa artefaktu zdefiniowana w jobie lint_and_test
          path: ./

      - name: Generate and Post Comment
        uses: actions/github-script@v7 # U≈ºywamy akcji github-script do wykonania skryptu JS
        env:
          # Przekazujemy wyniki (outcome) poprzednich krok√≥w jako zmienne ≈õrodowiskowe
          LINT_OUTCOME: ${{ needs.lint_and_test.outputs.lint_outcome }}
          TEST_OUTCOME: ${{ needs.lint_and_test.outputs.test_outcome }}
          LINT_RESULTS_PATH: ${{ needs.lint_and_test.outputs.lint_results_path }}
          TEST_RESULTS_PATH: ${{ needs.lint_and_test.outputs.test_results_path }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }} # Token do uwierzytelnienia w API GitHub
          script: |
            const fs = require('fs');
            const path = require('path');
            const { repo: { owner, repo }, issue: { number: issue_number } } = context;

            const lintOutcome = process.env.LINT_OUTCOME;
            const testOutcome = process.env.TEST_OUTCOME;
            const lintResultsPath = process.env.LINT_RESULTS_PATH;
            const testResultsPath = process.env.TEST_RESULTS_PATH;

            // --- Funkcje pomocnicze do parsowania wynik√≥w ---

            function parseLintResults(filePath) {
              try {
                if (!fs.existsSync(filePath)) return { success: lintOutcome === 'success', errors: 'N/A', warnings: 'N/A', error: 'Lint results file not found.' };
                // ESLint JSON format: array of objects, each with filePath, messages, errorCount, warningCount, etc.
                const results = JSON.parse(fs.readFileSync(filePath, 'utf8'));
                let totalErrors = 0;
                let totalWarnings = 0;
                results.forEach(fileResult => {
                  totalErrors += fileResult.errorCount;
                  totalWarnings += fileResult.warningCount;
                });
                // Uznajemy sukces tylko je≈õli *liczba* b≈Çƒôd√≥w = 0 (outcome mo≈ºe byƒá 'success' przez '|| true')
                const success = totalErrors === 0;
                return { success, errors: totalErrors, warnings: totalWarnings };
              } catch (error) {
                console.error("Error parsing lint results:", error);
                // Je≈õli parsowanie zawiedzie, bazujemy na outcome kroku
                return { success: lintOutcome === 'success', errors: 'N/A', warnings: 'N/A', error: 'Could not parse lint results file.' };
              }
            }

            function parseTestResults(filePath) {
              try {
                if (!fs.existsSync(filePath)) return { success: testOutcome === 'success', passed: 'N/A', failed: 'N/A', skipped: 'N/A', total: 'N/A', error: 'Test results file not found.' };
                // Vitest JSON format: { numTotalTestSuites, numPassedTests, numFailedTests, numPendingTests (or numSkippedTests?), testResults: [...] }
                const results = JSON.parse(fs.readFileSync(filePath, 'utf8'));
                const passed = results.numPassedTests ?? 0;
                const failed = results.numFailedTests ?? 0;
                // Sprawdzamy oba potencjalne klucze dla pominiƒôtych test√≥w
                const skipped = results.numPendingTests ?? results.numSkippedTests ?? 0;
                // Ca≈Çkowita liczba mo≈ºe byƒá dostƒôpna lub musimy jƒÖ obliczyƒá
                const total = results.numTotalTests ?? (passed + failed + skipped);
                // Uznajemy sukces tylko je≈õli *liczba* failed = 0
                const success = failed === 0;
                return { success, passed, failed, skipped, total };
              } catch (error) {
                console.error("Error parsing test results:", error);
                 // Je≈õli parsowanie zawiedzie, bazujemy na outcome kroku
                return { success: testOutcome === 'success', passed: 'N/A', failed: 'N/A', skipped: 'N/A', total: 'N/A', error: 'Could not parse test results file.' };
              }
            }

            // --- Przetwarzanie wynik√≥w ---
            const lintData = parseLintResults(path.basename(lintResultsPath)); // U≈ºywamy basename, bo plik jest w './'
            const testData = parseTestResults(path.basename(testResultsPath)); // U≈ºywamy basename

            // Og√≥lny status bazuje na sukcesie parsowanych danych
            const overallSuccess = lintData.success && testData.success;

            // --- Formatowanie komentarza ---
            const lintStatusIcon = lintData.success ? '‚úÖ' : '‚ùå';
            const testStatusIcon = testData.success ? '‚úÖ' : '‚ùå';
            const overallStatusIcon = overallSuccess ? '‚úÖ' : '‚ùå';
            const overallMessage = overallSuccess
              ? '‚úÖ All checks passed successfully.'
              : '‚ùå Some checks have failed. Please review the details above. ‚ö†Ô∏è';

            // Ukryty znacznik do znajdowania/aktualizowania komentarza
            const commentMarker = "<!-- github-actions-pr-comment-marker -->";

            const body = `${commentMarker}
            ## Pull Request Check Summary

            **Lint Results ${lintStatusIcon}**
            ${lintData.error ? `> Error: ${lintData.error}\n` : ''}\
            > ‚ùå Errors: ${lintData.errors}
            > ‚ö†Ô∏è Warnings: ${lintData.warnings}

            **Test Results ${testStatusIcon}**
            ${testData.error ? `> Error: ${testData.error}\n` : ''}\
            > **Test Statistics**
            > ‚úÖ Passed Tests: ${testData.passed}
            > ‚ùå Failed Tests: ${testData.failed}
            > ‚ö†Ô∏è Skipped Tests: ${testData.skipped}
            > üìä Total Tests: ${testData.total}

            ---
            **Overall Status ${overallStatusIcon}**
            ${overallMessage}
            `;

            // --- Logika publikowania/aktualizowania komentarza ---
            const octokit = github.getOctokit(process.env.GITHUB_TOKEN);
            let existingCommentId = null;

            try {
              console.log(`Listing comments for issue #${issue_number}...`);
              const { data: comments } = await octokit.rest.issues.listComments({
                owner,
                repo,
                issue_number,
              });
              const existingComment = comments.find(comment => comment.user.login === 'github-actions[bot]' && comment.body.includes(commentMarker));
              if (existingComment) {
                existingCommentId = existingComment.id;
                console.log(`Found existing comment ID: ${existingCommentId}`);
              } else {
                console.log("No existing comment found.");
              }
            } catch (error) {
              console.error("Error searching for existing comment:", error);
              // Kontynuuj pr√≥bƒô utworzenia nowego komentarza
            }

            try {
              if (existingCommentId) {
                console.log(`Updating comment ID: ${existingCommentId}`);
                await octokit.rest.issues.updateComment({
                  owner,
                  repo,
                  comment_id: existingCommentId,
                  body,
                });
                console.log("Comment updated successfully.");
              } else {
                console.log("Creating new comment...");
                await octokit.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number,
                  body,
                });
                console.log("Comment created successfully.");
              }
            } catch (error) {
               console.error("Error creating/updating comment:", error);
               core.setFailed(`Failed to post comment: ${error.message}`);
            }