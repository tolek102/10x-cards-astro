name: Pull Request Checks

on:
  pull_request:
    types: [opened, synchronize, reopened] # Uruchamiaj przy otwarciu, aktualizacji lub ponownym otwarciu PR

permissions: # Wymagane do dodawania komentarzy do PR
  pull-requests: write

jobs:
  lint:
    name: Lint Code
    runs-on: ubuntu-latest
    outputs: # UdostÄ™pnij wynik lintowania dla joba status-comment
      result: ${{ steps.run-lint.outcome }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup Node.js from .nvmrc
        uses: actions/setup-node@v4
        with:
          node-version-file: '.nvmrc' # UÅ¼yj wersji Node.js z pliku .nvmrc
          cache: 'npm' # WÅ‚Ä…cz cache dla npm

      - name: Install Dependencies
        run: npm ci # UÅ¼yj 'ci' dla czystej instalacji w CI

      - name: Run ESLint
        id: run-lint
        # Uruchom eslint, zapisz wynik do pliku JSON, kontynuuj nawet jeÅ›li sÄ… bÅ‚Ä™dy (`|| true`)
        # UÅ¼ywamy npx, aby upewniÄ‡ siÄ™, Å¼e uÅ¼ywamy wersji ESLint z projektu
        run: npx eslint . --format json --output-file eslint-report.json || true

      - name: Upload Lint Report Artifact
        # Zapisz raport jako artefakt, aby job status-comment mÃ³gÅ‚ go pobraÄ‡
        uses: actions/upload-artifact@v4
        with:
          name: lint-report # Nazwa artefaktu
          path: eslint-report.json # ÅšcieÅ¼ka do pliku raportu

  test:
    name: Run Unit Tests
    runs-on: ubuntu-latest
    needs: lint # Uruchom ten job po zakoÅ„czeniu joba 'lint'
    outputs: # UdostÄ™pnij wynik testÃ³w dla joba status-comment
      result: ${{ steps.run-tests.outcome }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup Node.js from .nvmrc
        uses: actions/setup-node@v4
        with:
          node-version-file: '.nvmrc'
          cache: 'npm'

      - name: Install Dependencies
        run: npm ci

      - name: Run Vitest with Coverage and JSON Report
        id: run-tests
        # Uruchom testy z pokryciem, zapisz wynik do pliku JSON, kontynuuj nawet jeÅ›li testy failujÄ… (`|| true`)
        # Vitest z reporterem json zawiera podsumowanie pokrycia
        run: npm run test:coverage -- --reporter=json --outputFile=vitest-report.json || true

      - name: Upload Test Report Artifact
        uses: actions/upload-artifact@v4
        with:
          name: test-report
          path: vitest-report.json # ÅšcieÅ¼ka do pliku raportu z testÃ³w i pokrycia

  status-comment:
    name: Post Status Comment
    runs-on: ubuntu-latest
    needs: [lint, test] # Uruchom ten job po zakoÅ„czeniu jobÃ³w 'lint' i 'test'
    if: always() # Zawsze uruchamiaj ten job, nawet jeÅ›li poprzednie zawiodÅ‚y, aby opublikowaÄ‡ status
    steps:
      - name: Checkout Code # Potrzebne do uzyskania kontekstu PR
        uses: actions/checkout@v4

      - name: Download Lint Report
        uses: actions/download-artifact@v4
        with:
          name: lint-report
          path: . # Pobierz do bieÅ¼Ä…cego katalogu

      - name: Download Test Report
        uses: actions/download-artifact@v4
        with:
          name: test-report
          path: .

      - name: Install jq # NarzÄ™dzie do parsowania JSON w linii komend
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Generate Comment Body
        id: generate-comment
        run: |
          # --- Initialize Variables ---
          LINT_STATUS="âœ…"
          LINT_ERRORS_COUNT=0
          LINT_WARNINGS_COUNT=0
          LINT_ERRORS_LIST=""
          LINT_WARNINGS_LIST=""
          LINT_REPORT_EXISTS=false
          TEST_STATUS="âœ…"
          TESTS_PASSED=0
          TESTS_FAILED=0
          TESTS_SKIPPED=0
          TESTS_TOTAL=0
          FAILED_TESTS_LIST=""
          SKIPPED_TESTS_LIST=""
          COVERAGE_SUMMARY=""
          COVERAGE_STATEMENTS=0
          COVERAGE_BRANCHES=0
          COVERAGE_FUNCTIONS=0
          COVERAGE_LINES=0
          OVERALL_STATUS_ICON="âœ…"
          OVERALL_STATUS_TEXT="All checks passed successfully."

          # --- Process Lint Report ---
          if [ -f eslint-report.json ]; then
            LINT_REPORT_EXISTS=true
            # Licz bÅ‚Ä™dy (severity 2) i ostrzeÅ¼enia (severity 1)
            LINT_ERRORS_COUNT=$(jq '[.[] | .messages[] | select(.severity == 2)] | length' eslint-report.json)
            LINT_WARNINGS_COUNT=$(jq '[.[] | .messages[] | select(.severity == 1)] | length' eslint-report.json)

            if [ "$LINT_ERRORS_COUNT" -gt 0 ]; then
              LINT_STATUS="âŒ"
              LINT_ERRORS_LIST=$(jq -r '.[] | select(any(.messages[]; .severity == 2)) | .filePath as $path | .messages[] | select(.severity == 2) | "- \($path | sub("^[^/]*/"; "src/")):\(.line):\(.column) - \(.message) (\(.ruleId // "unknown"))"' eslint-report.json | sed 's/^/  /')
            fi

            if [ "$LINT_WARNINGS_COUNT" -gt 0 ]; then
              # JeÅ›li sÄ… bÅ‚Ä™dy, status to juÅ¼ X, wpp ustaw na warning
              if [ "$LINT_STATUS" == "âœ…" ]; then LINT_STATUS="âš ï¸"; fi
              LINT_WARNINGS_LIST=$(jq -r '.[] | select(any(.messages[]; .severity == 1)) | .filePath as $path | .messages[] | select(.severity == 1) | "- \($path | sub("^[^/]*/"; "src/")):\(.line):\(.column) - \(.message) (\(.ruleId // "unknown"))"' eslint-report.json | sed 's/^/  /')
            fi
          else
            LINT_STATUS="â“" # Unknown status if file not found
            LINT_ERRORS_LIST="  - Lint report file (eslint-report.json) not found."
          fi

          # --- Process Test Report ---
          if [ -f vitest-report.json ]; then
            TESTS_PASSED=$(jq '.numPassedTests' vitest-report.json)
            TESTS_FAILED=$(jq '.numFailedTests' vitest-report.json)
            # Vitest moÅ¼e raportowaÄ‡ 'pending' jako skipped
            TESTS_SKIPPED=$(jq '.numPendingTests // .numTodoTests // 0' vitest-report.json)
            TESTS_TOTAL=$(jq '.numTotalTests' vitest-report.json)

            if [ "$TESTS_FAILED" -gt 0 ]; then
              TEST_STATUS="âŒ"
              # Zbierz nazwy failujÄ…cych testÃ³w
              FAILED_TESTS_LIST=$(jq -r '.testResults[] | select(.status == "failed") | .assertionResults[] | select(.status == "failed") | "- `\(.ancestorTitles | join(" > ")) > \(.title)`"' vitest-report.json | sed 's/^/  /')
            fi

            if [ "$TESTS_SKIPPED" -gt 0 ]; then
               # JeÅ›li nie ma bÅ‚Ä™dÃ³w, ale sÄ… skipped, status to warning
              if [ "$TEST_STATUS" == "âœ…" ]; then TEST_STATUS="âš ï¸"; fi
              SKIPPED_TESTS_LIST=$(jq -r '.testResults[] | .assertionResults[] | select(.status == "pending" or .status == "todo") | "- `\(.ancestorTitles | join(" > ")) > \(.title)`"' vitest-report.json | sed 's/^/  /')
            fi

            # --- Process Coverage ---
            # SprawdÅº czy raport zawiera podsumowanie pokrycia
            HAS_COVERAGE_SUMMARY=$(jq 'if .coverageMap and .coverageMap.summary then true else false end' vitest-report.json)
            if [ "$HAS_COVERAGE_SUMMARY" == "true" ]; then
              # UÅ¼yj // 0 aby zwrÃ³ciÄ‡ 0 jeÅ›li wartoÅ›Ä‡ jest null lub nie istnieje Å›cieÅ¼ka
              COVERAGE_STATEMENTS=$(jq '.coverageMap.summary.statements.pct // 0' vitest-report.json)
              COVERAGE_BRANCHES=$(jq '.coverageMap.summary.branches.pct // 0' vitest-report.json)
              COVERAGE_FUNCTIONS=$(jq '.coverageMap.summary.functions.pct // 0' vitest-report.json)
              COVERAGE_LINES=$(jq '.coverageMap.summary.lines.pct // 0' vitest-report.json)
              COVERAGE_SUMMARY=$(cat <<EOF
âœ… Code Coverage
- Statements: ${COVERAGE_STATEMENTS}%
- Branches: ${COVERAGE_BRANCHES}%
- Functions: ${COVERAGE_FUNCTIONS}%
- Lines: ${COVERAGE_LINES}%
EOF
)
            else
              COVERAGE_SUMMARY="âš ï¸ Code Coverage summary not found in test report."
            fi

          else
            TEST_STATUS="â“" # Unknown status if file not found
            FAILED_TESTS_LIST="  - Test report file (vitest-report.json) not found."
            COVERAGE_SUMMARY="â“ Code Coverage data unavailable."
          fi

          # --- Determine Overall Status ---
          if [ "${{ needs.lint.outputs.result }}" == "failure" ] || [ "${{ needs.test.outputs.result }}" == "failure" ] || [ "$LINT_STATUS" == "âŒ" ] || [ "$TEST_STATUS" == "âŒ" ]; then
              OVERALL_STATUS_ICON="âŒ"
              OVERALL_STATUS_TEXT="Some checks have failed. Please review the details above."
          elif [ "$LINT_STATUS" == "âš ï¸" ] || [ "$TEST_STATUS" == "âš ï¸" ]; then
              OVERALL_STATUS_ICON="âš ï¸"
              OVERALL_STATUS_TEXT="Some checks passed with warnings. Please review the details above."
          elif [ "$LINT_STATUS" == "â“" ] || [ "$TEST_STATUS" == "â“" ]; then
              OVERALL_STATUS_ICON="â“"
              OVERALL_STATUS_TEXT="Could not determine the status for all checks."
          fi


          # --- Construct Comment Body ---
          # Format failed tests list conditionally
          FAILED_TESTS_OUTPUT=""
          if [ "$TESTS_FAILED" -gt 0 ]; then
            FAILED_TESTS_OUTPUT=$(cat <<EOF

**Failed Tests:**
\`\`\`
${FAILED_TESTS_LIST}
\`\`\`
EOF
          )
          fi

          # Format skipped tests list conditionally
          SKIPPED_TESTS_OUTPUT=""
          if [ "$TESTS_SKIPPED" -gt 0 ]; then
            SKIPPED_TESTS_OUTPUT=$(cat <<EOF

**Skipped Tests:**
\`\`\`
${SKIPPED_TESTS_LIST}
\`\`\`
EOF
          )
          fi

          # UÅ¼ywamy heredoc EOF do Å‚atwiejszego formatowania wieloliniowego stringa
          COMMENT_BODY=$(cat <<EOF
## Pull Request Status

**Lint Results ${LINT_STATUS}**
${LINT_ERRORS_COUNT} Errors âŒ
\`\`\`diff
$( [ "$LINT_ERRORS_COUNT" -gt 0 ] && echo "$LINT_ERRORS_LIST" || echo "  + No errors found" )
\`\`\`
${LINT_WARNINGS_COUNT} Warnings âš ï¸
\`\`\`diff
$( [ "$LINT_WARNINGS_COUNT" -gt 0 ] && echo "$LINT_WARNINGS_LIST" || echo "  + No warnings found" )
\`\`\`

**Test Results ${TEST_STATUS}**
**Test Statistics**
âœ… Passed Tests: ${TESTS_PASSED}
âŒ Failed Tests: ${TESTS_FAILED}
âš ï¸ Skipped Tests: ${TESTS_SKIPPED}
ðŸ“Š Total Tests: ${TESTS_TOTAL}
${FAILED_TESTS_OUTPUT}
${SKIPPED_TESTS_OUTPUT}

${COVERAGE_SUMMARY}

---
**Overall Status**
${OVERALL_STATUS_ICON} ${OVERALL_STATUS_TEXT}
EOF
)

          # --- Output Comment Body for next step ---
          # Zapisz sformatowany komentarz do zmiennej GITHUB_OUTPUT
          # ZastÄ…p znaki nowej linii, aby pasowaÅ‚y do formatu GITHUB_OUTPUT
          echo "comment<<EOF" >> $GITHUB_OUTPUT
          echo "$COMMENT_BODY" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Create or Update Comment
        uses: peter-evans/create-or-update-comment@v4
        with:
          issue-number: ${{ github.event.pull_request.number }} # Numer PR z kontekstu zdarzenia
          # UÅ¼yj unikalnego ID, aby akcja mogÅ‚a znaleÅºÄ‡ i zaktualizowaÄ‡ swÃ³j poprzedni komentarz
          comment-id: ${{ github.run_id }}-${{ github.job }} # UÅ¼ywa ID bieÅ¼Ä…cego uruchomienia i joba dla unikalnoÅ›ci
          body: ${{ steps.generate-comment.outputs.comment }} # TreÅ›Ä‡ komentarza wygenerowana w poprzednim kroku
          edit-mode: replace # ZastÄ…p istniejÄ…cy komentarz o tym samym ID
