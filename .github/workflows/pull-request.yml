# .github/workflows/pull-request.yml
name: Pull Request Checks

# Uruchamiaj workflow dla Pull Requestów kierowanych do gałęzi 'master'
# dla zdarzeń: otwarcie, synchronizacja (nowy commit), ponowne otwarcie
on:
  pull_request:
    branches: [ master ] # Upewnij się, że nazwa gałęzi głównej jest poprawna (master/main)
    types: [ opened, synchronize, reopened ]

jobs:
  lint:
    name: Lint Code
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Set up Node.js from .nvmrc
        uses: actions/setup-node@v4
        with:
          node-version-file: '.nvmrc' # Używa wersji Node.js z pliku .nvmrc
          cache: 'npm' # Włącza cache'owanie zależności npm

      - name: Install Dependencies
        run: npm ci # Używaj 'ci' dla czystej instalacji w CI/CD

      - name: Run ESLint
        id: lint-step # Nadajemy ID krokowi, aby sprawdzić jego wynik później
        # Uruchamia lintowanie. Pozwalamy na kontynuację nawet jeśli są błędy,
        # aby móc uruchomić testy i finalny komentarz.
        run: npm run lint
        continue-on-error: true # Nie zatrzymuj workflow, jeśli lintowanie zawiedzie

  test:
    name: Unit Tests
    runs-on: ubuntu-latest
    needs: lint # Uruchom ten job dopiero po zakończeniu joba 'lint' (nawet jeśli się nie powiedzie)
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Set up Node.js from .nvmrc
        uses: actions/setup-node@v4
        with:
          node-version-file: '.nvmrc'
          cache: 'npm'

      - name: Install Dependencies
        run: npm ci

      - name: Run Unit Tests with Coverage
        id: test-step # Nadajemy ID krokowi
        # Uruchamia testy z coverage. Dodajemy reportera JSON, aby łatwo sparsować wyniki.
        # Flaga '--' przekazuje argumenty bezpośrednio do vitest.
        run: npm run test:coverage -- --reporter=json --outputFile=vitest-summary.json
        continue-on-error: true # Nie zatrzymuj workflow, jeśli testy zawiodą

      - name: Upload Test Summary Artifact
        # Zapisuje podsumowanie testów jako artefakt, aby job z komentarzem mógł je odczytać
        uses: actions/upload-artifact@v4
        if: always() # Zawsze próbuj zapisać artefakt, nawet jeśli krok testów się nie powiódł
        with:
          name: test-summary
          path: vitest-summary.json
          retention-days: 1 # Przechowuj artefakt tylko przez 1 dzień

      - name: Upload Coverage Artifact
        # Zapisuje pełny raport coverage jako artefakt (opcjonalne, ale przydatne)
        uses: actions/upload-artifact@v4
        if: always() # Zawsze próbuj zapisać artefakt
        with:
          name: coverage-report
          path: coverage/ # Domyślny katalog dla raportów coverage Vitest
          retention-days: 5

  status-comment:
    name: Post Status Comment
    runs-on: ubuntu-latest
    needs: [lint, test] # Uruchom ten job po zakończeniu 'lint' i 'test'
    # Uruchamiaj ten job zawsze, nawet jeśli poprzednie zawiodły, aby podsumować status
    if: always()
    permissions:
      pull-requests: write # Wymagane uprawnienia do dodawania komentarzy do PR

    steps:
      - name: Download Test Summary Artifact
        uses: actions/download-artifact@v4
        with:
          name: test-summary
        # Ignoruj błąd, jeśli artefakt nie istnieje (np. job testowy zawiódł bardzo wcześnie)
        continue-on-error: true

      - name: Create Status Comment
        uses: actions/github-script@v7
        id: comment-script
        # Dostęp do 'needs' jest przez obiekt 'context'
        # context.needs.<job_id>.result zwraca 'success', 'failure', 'cancelled', or 'skipped'
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const prNumber = context.issue.number;
            if (!prNumber) {
              console.log('Could not get PR number from context, exiting');
              core.setFailed('Could not get PR number from context.'); // Oznacz krok jako nieudany
              return;
            }

            // --- Status Lintowania ---
            // Używamy 'context.needs' zamiast 'needs'
            const lintResult = context.needs.lint.result;
            const lintStatus = lintResult === 'success' ? '✅' : '❌';
            let lintComment = `Lint Results ${lintStatus}\n`;
            if (lintResult !== 'success') {
              // W przyszłości można dodać parsowanie logów lub outputu JSON z ESLint dla szczegółów
              lintComment += `❌ Linting failed. Please check the 'Lint Code' job logs for details.\n`;
            } else {
               lintComment += `✅ Linting passed.\n`;
            }

            // --- Status Testów ---
            // Używamy 'context.needs' zamiast 'needs'
            const testResult = context.needs.test.result;
            const testStatus = testResult === 'success' ? '✅' : '❌';
            let testComment = `\nTest Results ${testStatus}\n`;
            let passedTests = 0;
            let failedTests = 0;
            let skippedTests = 0; // Vitest oznacza je jako 'pending' lub 'todo'
            let totalTests = 0;
            let testStatsAvailable = false;
            const summaryPath = './vitest-summary.json'; // Ścieżka do pobranego artefaktu

            try {
              // Sprawdź, czy plik podsumowania istnieje (mógł nie zostać pobrany, jeśli job testowy zawiódł wcześnie)
              if (fs.existsSync(summaryPath)) {
                const summaryRaw = fs.readFileSync(summaryPath, 'utf8');
                const summary = JSON.parse(summaryRaw);

                // Sprawdź, czy struktura summary jest oczekiwana
                if (summary && summary.testResults && Array.isArray(summary.testResults)) {
                    summary.testResults.forEach(fileResult => {
                      if (fileResult && fileResult.assertionResults && Array.isArray(fileResult.assertionResults)) {
                        passedTests += fileResult.assertionResults.filter(r => r && r.status === 'passed').length;
                        failedTests += fileResult.assertionResults.filter(r => r && r.status === 'failed').length;
                        skippedTests += fileResult.assertionResults.filter(r => r && (r.status === 'pending' || r.status === 'todo')).length;
                        // Niektóre wersje mogą mieć 'skipped' zamiast 'pending'/'todo'
                        skippedTests += fileResult.assertionResults.filter(r => r && r.status === 'skipped').length;
                        totalTests += fileResult.assertionResults.length;
                      } else {
                         console.warn('Unexpected structure within testResults item:', fileResult);
                      }
                    });
                    testStatsAvailable = true;
                 } else if (summary && typeof summary.numTotalTests !== 'undefined') {
                    // Alternatywna struktura, czasami Vitest umieszcza podsumowanie na górnym poziomie
                    passedTests = summary.numPassedTests ?? 0;
                    failedTests = summary.numFailedTests ?? 0;
                    skippedTests = (summary.numPendingTests ?? 0) + (summary.numTodoTests ?? 0) + (summary.numSkippedTests ?? 0) ;
                    totalTests = summary.numTotalTests ?? 0;
                    testStatsAvailable = true;
                 } else {
                    console.warn('Unexpected vitest summary JSON structure:', summary);
                 }

                if (testStatsAvailable) {
                  testComment += `Test Statistics\n`;
                  testComment += `✅ Passed Tests: ${passedTests}\n`;
                  testComment += failedTests > 0 ? `❌ Failed Tests: ${failedTests}\n` : `✅ Failed Tests: 0\n`;
                  testComment += skippedTests > 0 ? `⚠️ Skipped Tests: ${skippedTests}\n` : `✅ Skipped Tests: 0\n`;
                  testComment += `📊 Total Tests Run: ${totalTests}\n`; // Używamy totalTests z pliku JSON
                } else if (testResult === 'success') {
                  // Jeśli testy przeszły, ale nie udało się sparsować statystyk
                  testComment += `✅ Tests passed, but failed to parse detailed statistics from vitest-summary.json.\n`;
                }

              } else {
                 // Plik nie istnieje
                 testComment += `⚠️ Could not find test summary file (${summaryPath}).\n`;
                 if (testResult !== 'success') {
                   testComment += `❌ Tests failed. Check the 'Unit Tests' job logs for details.\n`;
                 } else {
                   // Rzadki przypadek: job 'test' sukces, ale artefakt nie istnieje/nie pobrał się?
                   testComment += `🤔 Tests job reported success, but the summary artifact is missing.\n`;
                 }
              }
            } catch (error) {
              console.error("Error processing test summary:", error);
              testComment += `⚠️ Error processing test results.\n`;
               if (testResult !== 'success') {
                 testComment += `❌ Tests failed. Check the 'Unit Tests' job logs for details.\n`;
               }
            }

             // --- Status Ogólny ---
            let overallStatus = '\nOverall Status\n';
            // Używamy zmiennych 'lintResult' i 'testResult'
            if (lintResult === 'success' && testResult === 'success') {
              overallStatus += '✅ All checks passed successfully!';
            } else {
              overallStatus += '❌ Some checks have failed. Please review the details above. ⚠️';
            }

            // --- Konstrukcja finalnego komentarza ---
            const finalComment = `${lintComment}${testComment}${overallStatus}`;

            // --- Publikacja komentarza ---
            // Dodaj logikę do edycji/aktualizacji komentarza, jeśli to preferowane
            // Na razie tworzymy nowy
            try {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: finalComment
              });
            } catch (commentError) {
               console.error("Failed to create comment:", commentError);
               // Możesz chcieć oznaczyć krok jako nieudany, jeśli komentowanie jest krytyczne
               // core.setFailed('Failed to post status comment.');
            }