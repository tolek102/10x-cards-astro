# .github/workflows/pull-request.yml
name: Pull Request Checks

# Uruchamiaj workflow dla Pull RequestÃ³w kierowanych do gaÅ‚Ä™zi 'master'
# dla zdarzeÅ„: otwarcie, synchronizacja (nowy commit), ponowne otwarcie
on:
  pull_request:
    branches: [ master ] # Upewnij siÄ™, Å¼e nazwa gaÅ‚Ä™zi gÅ‚Ã³wnej jest poprawna (master/main)
    types: [ opened, synchronize, reopened ]

jobs:
  lint:
    name: Lint Code
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Set up Node.js from .nvmrc
        uses: actions/setup-node@v4
        with:
          node-version-file: '.nvmrc' # UÅ¼ywa wersji Node.js z pliku .nvmrc
          cache: 'npm' # WÅ‚Ä…cza cache'owanie zaleÅ¼noÅ›ci npm

      - name: Install Dependencies
        run: npm ci # UÅ¼ywaj 'ci' dla czystej instalacji w CI/CD

      - name: Run ESLint
        id: lint-step # Nadajemy ID krokowi, aby sprawdziÄ‡ jego wynik pÃ³Åºniej
        # Uruchamia lintowanie. Pozwalamy na kontynuacjÄ™ nawet jeÅ›li sÄ… bÅ‚Ä™dy,
        # aby mÃ³c uruchomiÄ‡ testy i finalny komentarz.
        run: npm run lint
        continue-on-error: true # Nie zatrzymuj workflow, jeÅ›li lintowanie zawiedzie

  test:
    name: Unit Tests
    runs-on: ubuntu-latest
    needs: lint # Uruchom ten job dopiero po zakoÅ„czeniu joba 'lint' (nawet jeÅ›li siÄ™ nie powiedzie)
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Set up Node.js from .nvmrc
        uses: actions/setup-node@v4
        with:
          node-version-file: '.nvmrc'
          cache: 'npm'

      - name: Install Dependencies
        run: npm ci

      - name: Run Unit Tests with Coverage
        id: test-step # Nadajemy ID krokowi
        # Uruchamia testy z coverage. Dodajemy reportera JSON, aby Å‚atwo sparsowaÄ‡ wyniki.
        # Flaga '--' przekazuje argumenty bezpoÅ›rednio do vitest.
        run: npm run test:coverage -- --reporter=json --outputFile=vitest-summary.json
        continue-on-error: true # Nie zatrzymuj workflow, jeÅ›li testy zawiodÄ…

      - name: Upload Test Summary Artifact
        # Zapisuje podsumowanie testÃ³w jako artefakt, aby job z komentarzem mÃ³gÅ‚ je odczytaÄ‡
        uses: actions/upload-artifact@v4
        if: always() # Zawsze prÃ³buj zapisaÄ‡ artefakt, nawet jeÅ›li krok testÃ³w siÄ™ nie powiÃ³dÅ‚
        with:
          name: test-summary
          path: vitest-summary.json
          retention-days: 1 # Przechowuj artefakt tylko przez 1 dzieÅ„

      - name: Upload Coverage Artifact
        # Zapisuje peÅ‚ny raport coverage jako artefakt (opcjonalne, ale przydatne)
        uses: actions/upload-artifact@v4
        if: always() # Zawsze prÃ³buj zapisaÄ‡ artefakt
        with:
          name: coverage-report
          path: coverage/ # DomyÅ›lny katalog dla raportÃ³w coverage Vitest
          retention-days: 5

  status-comment:
    name: Post Status Comment
    runs-on: ubuntu-latest
    needs: [lint, test] # Uruchom ten job po zakoÅ„czeniu 'lint' i 'test'
    # Uruchamiaj ten job zawsze, nawet jeÅ›li poprzednie zawiodÅ‚y, aby podsumowaÄ‡ status
    if: always()
    permissions:
      pull-requests: write # Wymagane uprawnienia do dodawania komentarzy do PR

    steps:
      - name: Download Test Summary Artifact
        uses: actions/download-artifact@v4
        with:
          name: test-summary
        # Ignoruj bÅ‚Ä…d, jeÅ›li artefakt nie istnieje (np. job testowy zawiÃ³dÅ‚ bardzo wczeÅ›nie)
        continue-on-error: true

      - name: Create Status Comment
        uses: actions/github-script@v7
        id: comment-script
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const prNumber = context.issue.number;
            if (!prNumber) {
              console.log('Could not get PR number from context, exiting');
              return;
            }

            // --- Status Lintowania ---
            const lintStatus = needs.lint.result === 'success' ? 'âœ…' : 'âŒ';
            let lintComment = `Lint Results ${lintStatus}\n`;
            // Uwaga: Pobranie dokÅ‚adnej liczby bÅ‚Ä™dÃ³w/ostrzeÅ¼eÅ„ z `npm run lint`
            // wymagaÅ‚oby bardziej zÅ‚oÅ¼onego parsowania outputu lub uÅ¼ycia formattera JSON dla ESLint.
            // Dla uproszczenia, pokazujemy tylko ogÃ³lny status sukces/poraÅ¼ka.
            // JeÅ›li lintowanie zawiodÅ‚o, dodajemy informacjÄ™.
            if (needs.lint.result !== 'success') {
              lintComment += `âŒ Linting failed. Please check the 'Lint Code' job logs for details.\n`;
            } else {
               lintComment += `âœ… Linting passed.\n`;
            }

            // --- Status TestÃ³w ---
            const testStatus = needs.test.result === 'success' ? 'âœ…' : 'âŒ';
            let testComment = `\nTest Results ${testStatus}\n`;
            let passedTests = 0;
            let failedTests = 0;
            let skippedTests = 0; // Vitest oznacza je jako 'pending' lub 'todo'
            let totalTests = 0;
            let testStatsAvailable = false;

            try {
              if (fs.existsSync('./vitest-summary.json')) {
                const summaryRaw = fs.readFileSync('./vitest-summary.json', 'utf8');
                const summary = JSON.parse(summaryRaw);
                // Sumujemy statystyki ze wszystkich plikÃ³w testowych w raporcie
                summary.testResults.forEach(fileResult => {
                  passedTests += fileResult.assertionResults.filter(r => r.status === 'passed').length;
                  failedTests += fileResult.assertionResults.filter(r => r.status === 'failed').length;
                  skippedTests += fileResult.assertionResults.filter(r => r.status === 'pending' || r.status === 'todo').length;
                  totalTests += fileResult.assertionResults.length;
                });
                // Vitest JSON reporter w starszych wersjach mÃ³gÅ‚ mieÄ‡ innÄ… strukturÄ™.
                // Alternatywnie, moÅ¼na uÅ¼yÄ‡ pÃ³l `numPassedTests`, `numFailedTests`, etc. jeÅ›li sÄ… na top-level.
                // Dostosuj logikÄ™ parsowania w razie potrzeby do dokÅ‚adnej struktury Twojego `vitest-summary.json`.
                // PrzykÅ‚adowe pola z nowszych wersji Vitest (jeÅ›li dostÄ™pne):
                // passedTests = summary.numPassedTests ?? passedTests;
                // failedTests = summary.numFailedTests ?? failedTests;
                // skippedTests = summary.numPendingTests ?? skippedTests;
                // totalTests = summary.numTotalTests ?? totalTests;

                testStatsAvailable = true;

                testComment += `Test Statistics\n`;
                testComment += `âœ… Passed Tests: ${passedTests}\n`;
                testComment += failedTests > 0 ? `âŒ Failed Tests: ${failedTests}\n` : `âœ… Failed Tests: 0\n`;
                testComment += skippedTests > 0 ? `âš ï¸ Skipped Tests: ${skippedTests}\n` : `âœ… Skipped Tests: 0\n`;
                testComment += `ğŸ“Š Total Tests Run: ${totalTests}\n`; // MoÅ¼na uÅ¼yÄ‡ totalTests lub sumy passed+failed+skipped
              } else {
                 testComment += `âš ï¸ Could not find test summary file (vitest-summary.json).\n`;
                 if (needs.test.result !== 'success') {
                   testComment += `âŒ Tests failed. Check the 'Unit Tests' job logs.\n`;
                 }
              }
            } catch (error) {
              console.error("Error parsing test summary:", error);
              testComment += `âš ï¸ Error processing test results.\n`;
               if (needs.test.result !== 'success') {
                 testComment += `âŒ Tests failed. Check the 'Unit Tests' job logs.\n`;
               }
            }

            // --- Status OgÃ³lny ---
            let overallStatus = '\nOverall Status\n';
            if (needs.lint.result === 'success' && needs.test.result === 'success') {
              overallStatus += 'âœ… All checks passed successfully!';
            } else {
              overallStatus += 'âŒ Some checks have failed. Please review the details above. âš ï¸';
            }

            // --- Konstrukcja finalnego komentarza ---
            const finalComment = `${lintComment}${testComment}${overallStatus}`;

            // --- Publikacja komentarza ---
            // MoÅ¼na dodaÄ‡ logikÄ™ do edycji istniejÄ…cego komentarza zamiast tworzenia nowego za kaÅ¼dym razem
            // ale dla uproszczenia tworzymy nowy.
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: finalComment
            });

      - name: Fail workflow if checks failed
        # Ten krok jawnie oznacza workflow jako nieudany, jeÅ›li lint lub testy zawiodÅ‚y.
        # Bez tego, workflow mÃ³gÅ‚by pokazaÄ‡ zielony âœ“, bo job 'status-comment' siÄ™ udaÅ‚.
        if: needs.lint.result != 'success' || needs.test.result != 'success'
        run: exit 1